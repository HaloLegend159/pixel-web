<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dripping Pixel Orb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      cursor: crosshair;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
    }
    .hint {
      position: fixed;
      left: 16px;
      bottom: 12px;
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      pointer-events: none;
      user-select: none;
      transition: opacity 1.0s ease 3s;
    }
    .hint.fade {
      opacity: 0;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint" id="hint">Move your mouse â€“ pixel orb will drip</div>

<script>
/* ========== Canvas setup ========== */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = innerWidth  * dpr;
  canvas.height = innerHeight * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
}
window.addEventListener("resize", resize);
resize();

/* ========== Palette (lava colors) ========== */
function hexToRgb(hex) {
  hex = hex.replace("#", "");
  if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
  const num = parseInt(hex, 16);
  return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
}

const paletteStops = [
  "#100000",
  "#3b0202",
  "#7e0505",
  "#ff1f1f",
  "#ffb347"
].map(hexToRgb);

function lerp(a,b,t){return a+(b-a)*t;}
function clamp01(x){return x<0?0:x>1?1:x;}

function sampleGradient(t) {
  t = clamp01(t);
  const n = paletteStops.length;
  const scaled = t * (n - 1);
  const i = Math.floor(scaled);
  const f = scaled - i;
  const a = paletteStops[i];
  const b = paletteStops[Math.min(i + 1, n - 1)];
  return {
    r: Math.round(lerp(a.r, b.r, f)),
    g: Math.round(lerp(a.g, b.g, f)),
    b: Math.round(lerp(a.b, b.b, f))
  };
}

/* ========== Cursor orb + drips ========== */
const orb = {
  x: innerWidth / 2,
  y: innerHeight / 2,
  radius: 90,      // visual radius in pixels
  targetX: innerWidth / 2,
  targetY: innerHeight / 2,
  smoothing: 0.22, // how much it eases toward the cursor
  lastMoveTime: performance.now()
};

window.addEventListener("pointermove", e => {
  const rect = canvas.getBoundingClientRect();
  orb.targetX = e.clientX - rect.left;
  orb.targetY = e.clientY - rect.top;
  orb.lastMoveTime = performance.now();
  // fade out hint text after first move
  const hint = document.getElementById("hint");
  if (hint && !hint.classList.contains("fade")) {
    hint.classList.add("fade");
  }
});

/* Each drip is a vertical stream anchored under the orb */
const drips = [];
const MAX_DRIPS = 60;
let lastDripSpawn = 0;

function spawnDripSet(time) {
  const baseY = orb.y + orb.radius * 0.4; // bottom of orb
  const offsets = [-0.45, -0.18, 0.18, 0.45]; // left, inner-left, inner-right, right

  offsets.forEach((off, idx) => {
    const x = orb.x + orb.radius * off;
    drips.push({
      x,
      y0: baseY,
      start: time,
      speed: 200 + Math.random() * 120, // px per second
      width: 26 + Math.random() * 18,   // horizontal width
      strength: 0.9 + Math.random() * 0.6,
      wobblePhase: Math.random() * Math.PI * 2,
      wobbleAmp: 10 + Math.random() * 12
    });
  });

  while (drips.length > MAX_DRIPS) drips.shift();
}

/* ========== Field sampling ========== */

// dripping intensity 0..1 at pixel position
function dripField(x, y, time) {
  let v = 0;
  for (let i = 0; i < drips.length; i++) {
    const d = drips[i];
    const age = (time - d.start) / 1000; // seconds
    if (age < 0) continue;

    // drifting head with wobble
    const headY = d.y0 + d.speed * age;
    if (headY - 30 > canvas.height) continue; // below screen

    // only below the orb base
    if (y < d.y0 - 15) continue;

    const wobble = Math.sin(age * 3.0 + d.wobblePhase) * d.wobbleAmp;
    const cx = d.x + wobble;

    const dx = x - cx;
    const ax = Math.abs(dx);
    if (ax > d.width) continue;

    // vertical profile: strongest near head, with a tail
    const dy = y - headY;
    if (dy > 90) continue; // too far below

    const vertical = Math.exp(-Math.max(-40, dy) * 0.025);
    const horizontal = 1.0 - ax / d.width;
    let local = d.strength * vertical * horizontal;

    // overall lifetime fade
    const lifeFade = Math.exp(-age * 0.9);
    local *= lifeFade;

    if (local > v) v = local;
  }
  return clamp01(v);
}

// orb intensity 0..1 at pixel position
function orbField(x, y, time) {
  const dx = x - orb.x;
  const dy = y - orb.y;
  const r = Math.sqrt(dx*dx + dy*dy);
  const core = orb.radius * 0.6;
  const outer = orb.radius;
  if (r > outer) return 0;

  // soft edge
  let tVal = 1 - (r - core) / (outer - core);
  if (r < core) tVal = 1;
  tVal = clamp01(tVal);

  // subtle breathing so it feels alive
  const breath = 0.06 * Math.sin(time * 0.0015);
  tVal = clamp01(tVal + breath);

  return tVal;
}

/* ========== Render loop ========== */
const BASE_GRID = 110; // how many blocks on the short side

let lastTime = performance.now();

function render(time) {
  const dt = (time - lastTime) / 1000;
  lastTime = time;

  const w = innerWidth;
  const h = innerHeight;
  const shortSide = Math.min(w, h);
  const grid = BASE_GRID;
  const cell = shortSide / grid;
  const cols = Math.ceil(w / cell);
  const rows = Math.ceil(h / cell);

  // smooth orb motion
  orb.x = lerp(orb.x, orb.targetX, orb.smoothing);
  orb.y = lerp(orb.y, orb.targetY, orb.smoothing);

  ctx.fillStyle = "#000000";
  ctx.fillRect(0, 0, w, h);

  // spawn drips regularly while user has moved recently
  if (time - orb.lastMoveTime < 2200) { // 2.2s after last move
    if (time - lastDripSpawn > 120) {   // every 120 ms
      spawnDripSet(time);
      lastDripSpawn = time;
    }
  }

  // draw pixel grid
  for (let j = 0; j < rows; j++) {
    for (let i = 0; i < cols; i++) {
      const px = (i + 0.5) * cell;
      const py = (j + 0.5) * cell;

      let vOrb = orbField(px, py, time);
      let vDrip = dripField(px, py, time);

      // combine: orb dominates near center, drips extend downward
      let v = Math.max(vOrb, vDrip);
      if (v <= 0.01) continue; // leave pure black

      // a little curve so mids pop and noise is smooth
      v = Math.pow(v, 0.8);

      const col = sampleGradient(v);
      ctx.fillStyle = `rgb(${col.r},${col.g},${col.b})`;
      ctx.fillRect(
        Math.floor(i * cell),
        Math.floor(j * cell),
        Math.ceil(cell)+1,
        Math.ceil(cell)+1
      );
    }
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
