<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Particle Gravity Field</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      cursor: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
    }
    .hint {
      position: fixed;
      left: 16px;
      bottom: 14px;
      font-size: 11px;
      color: rgba(255,255,255,0.4);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      pointer-events: none;
      user-select: none;
      transition: opacity 1s ease 3s;
    }
    .hint.fade { opacity: 0; }

    .cursor-dot {
      position: fixed;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 30% 30%, #ffffff, #60a5ff, transparent 70%);
      mix-blend-mode: screen;
      filter: blur(0.5px);
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="cursor-dot" id="cursorDot"></div>
<div class="hint" id="hint">Move your mouse – particles will bend toward it</div>

<script>
/* ================= Canvas setup ================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = innerWidth  * dpr;
  canvas.height = innerHeight * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ================= Particle system ================= */

// Configuration
const PARTICLE_COUNT = 1000;
const HOME_FORCE     = 0.05;   // how strongly particles are pulled back to their home
const FRICTION       = 0.86;   // velocity damping
const GRAVITY_STRENGTH = 9000; // pull toward cursor
const INFLUENCE_RADIUS = 220;  // pixels around cursor
const MIN_DISTANCE     = 18;   // avoid exploding when cursor is too close
const PARTICLE_SIZE    = 2.0;  // base size in pixels

let particles = [];

// track mouse
const mouse = {
  x: innerWidth / 2,
  y: innerHeight / 2,
  isActive: false
};

window.addEventListener("pointermove", (e) => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
  mouse.isActive = true;

  const dot = document.getElementById("cursorDot");
  dot.style.left = e.clientX + "px";
  dot.style.top  = e.clientY + "px";

  const hint = document.getElementById("hint");
  if (hint && !hint.classList.contains("fade")) {
    hint.classList.add("fade");
  }
});

window.addEventListener("pointerleave", () => {
  mouse.isActive = false;
});

// Initialize particles in a loose grid, so it looks “composed”
function initParticles() {
  particles = [];
  const cols = Math.round(Math.sqrt(PARTICLE_COUNT) * (innerWidth / innerHeight) || 1);
  const rows = Math.round(PARTICLE_COUNT / cols);

  const margin = 80;
  const usableW = innerWidth - margin * 2;
  const usableH = innerHeight - margin * 2;

  for (let j = 0; j < rows; j++) {
    for (let i = 0; i < cols; i++) {
      if (particles.length >= PARTICLE_COUNT) break;

      const fx = (i + 0.5) / cols;
      const fy = (j + 0.5) / rows;
      const homeX = margin + fx * usableW + (Math.random() - 0.5) * 8;
      const homeY = margin + fy * usableH + (Math.random() - 0.5) * 8;

      particles.push({
        x: homeX,
        y: homeY,
        vx: 0,
        vy: 0,
        hx: homeX,
        hy: homeY,
        jitterPhase: Math.random() * Math.PI * 2,
        jitterSpeed: 0.5 + Math.random() * 0.8,
        brightness: 0.4 + Math.random() * 0.6
      });
    }
  }
}

initParticles();
window.addEventListener("resize", initParticles);

/* ================= Animation loop ================= */

let lastTime = performance.now();

function render(time) {
  const dt = (time - lastTime) / 1000;
  lastTime = time;

  const w = innerWidth;
  const h = innerHeight;

  // trailing clear for nice motion blur
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(0, 0, w, h);

  const radius2 = INFLUENCE_RADIUS * INFLUENCE_RADIUS;

  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];

    // soft "breathing" jitter even when idle
    const jPhase = p.jitterPhase + time * 0.001 * p.jitterSpeed;
    const jx = Math.cos(jPhase) * 0.4;
    const jy = Math.sin(jPhase * 0.9) * 0.4;

    // Pull back to home
    let dxHome = p.hx - p.x;
    let dyHome = p.hy - p.y;
    p.vx += dxHome * HOME_FORCE * dt;
    p.vy += dyHome * HOME_FORCE * dt;

    // Cursor gravity
    if (mouse.isActive) {
      const dx = mouse.x - p.x;
      const dy = mouse.y - p.y;
      const dist2 = dx * dx + dy * dy;
      if (dist2 < radius2 && dist2 > MIN_DISTANCE * MIN_DISTANCE) {
        const dist = Math.sqrt(dist2);
        // force decays with distance, stronger when closer
        const force = (GRAVITY_STRENGTH * dt) / (dist2 + 40);
        const fx = (dx / dist) * force;
        const fy = (dy / dist) * force;
        p.vx += fx;
        p.vy += fy;
      }
    }

    // apply small jitter
    p.vx += jx * 0.02;
    p.vy += jy * 0.02;

    // friction
    p.vx *= FRICTION;
    p.vy *= FRICTION;

    // integrate
    p.x += p.vx;
    p.y += p.vy;

    // draw
    const vMag = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
    const speedFactor = Math.min(vMag * 4.0, 1.0);
    const glow = p.brightness * (0.5 + speedFactor * 0.7);

    const col = mixColor(glow);
    ctx.fillStyle = col;

    const size = PARTICLE_SIZE + speedFactor * 2.0;
    // draw small square pixel particles
    ctx.fillRect(
      p.x - size * 0.5,
      p.y - size * 0.5,
      size,
      size
    );
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* ================= Color helper ================= */

// Map brightness 0..1 into subtle cyan/blue/white ramp
function mixColor(t) {
  t = clamp01(t);
  const c1 = { r: 120, g: 180, b: 255 }; // soft cyan
  const c2 = { r: 200, g: 220, b: 255 }; // pale white-blue
  const r = Math.round(c1.r + (c2.r - c1.r) * t);
  const g = Math.round(c1.g + (c2.g - c1.g) * t);
  const b = Math.round(c1.b + (c2.b - c1.b) * t);
  return `rgb(${r},${g},${b})`;
}
</script>
</body>
</html>
