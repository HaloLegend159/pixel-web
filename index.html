<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Drippy Pixel Field</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      cursor: crosshair;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
    }
    .hint {
      position: fixed;
      left: 16px;
      bottom: 12px;
      font-size: 11px;
      color: rgba(255,255,255,0.35);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Move your mouse to create drippy pixels</div>

<script>
/* ------- Setup ------- */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = innerWidth  * dpr;
  canvas.height = innerHeight * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
}
window.addEventListener("resize", resize);
resize();

/* ------- Palette / gradient ------- */
function hexToRgb(hex) {
  hex = hex.replace("#", "");
  if (hex.length === 3) {
    hex = hex[0]+hex[0] + hex[1]+hex[1] + hex[2]+hex[2];
  }
  const num = parseInt(hex, 16);
  return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
}

// Lava-style ramp
const paletteStops = [
  "#1a0000",
  "#4d0505",
  "#960707",
  "#ff1f1f",
  "#ffb347",
].map(hexToRgb);

function sampleGradient(t) {
  t = Math.max(0, Math.min(1, t));
  const n = paletteStops.length;
  const scaled = t * (n - 1);
  const i = Math.floor(scaled);
  const f = scaled - i;
  const a = paletteStops[i];
  const b = paletteStops[Math.min(i + 1, n - 1)];
  return {
    r: Math.round(a.r + (b.r - a.r) * f),
    g: Math.round(a.g + (b.g - a.g) * f),
    b: Math.round(a.b + (b.b - a.b) * f),
  };
}

/* ------- Drip field ------- */

// Each drip is a vertical streak that falls & fades
const drips = [];
const MAX_DRIPS = 80;

function spawnDrip(nx, ny) {
  drips.push({
    x: nx,          // normalized 0..1
    y0: ny,         // starting y (normalized)
    start: performance.now(),
    speed: 0.15 + Math.random() * 0.25,  // normalized units per second
    radius: 0.06 + Math.random() * 0.04, // horizontal influence radius
    strength: 0.7 + Math.random() * 0.5, // initial intensity
  });
  if (drips.length > MAX_DRIPS) drips.shift();
}

// mouse → spawn drips
function handlePointer(e) {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;
  spawnDrip(x, y);
}
window.addEventListener("pointermove", handlePointer);

/* ------- Field sampling ------- */

function driftNoise(nx, ny, t) {
  // simple time-based wobble to break up shapes
  return Math.sin((nx * 10 + t * 0.0017)) * 0.3 +
         Math.cos((ny * 14 - t * 0.0013)) * 0.3;
}

// returns intensity 0..1 at (nx,ny) given all drips
function dripField(nx, ny, time) {
  let v = 0;
  for (let i = 0; i < drips.length; i++) {
    const d = drips[i];
    const age = (time - d.start) / 1000; // seconds
    if (age < 0) continue;

    const headY = d.y0 + age * d.speed; // current drip head position
    if (headY - d.radius > 1.2) continue; // off-screen

    const dx = Math.abs(nx - d.x);
    if (dx > d.radius) continue;

    if (ny < d.y0) continue;          // nothing above origin
    if (ny > headY + 0.25) continue;  // fade after head passes

    const dy = ny - headY; // 0 at head
    // vertical fall attenuation (negative dy = above head → stronger)
    const vertical = Math.exp(-Math.max(0, dy + 0.01) * 9);
    const horizontal = 1 - dx / d.radius;
    let local = d.strength * vertical * horizontal;

    // older drips fade
    const lifeFade = Math.exp(-age * 0.8);
    local *= lifeFade;

    if (local > v) v = local;
  }
  return Math.max(0, Math.min(1, v));
}

/* ------- Render loop ------- */

let lastW = innerWidth;
let lastH = innerHeight;
// gridSize = number of "pixels" across the short side
const BASE_GRID = 90;

function render(time) {
  const w = innerWidth;
  const h = innerHeight;
  if (w !== lastW || h !== lastH) {
    resize();
    lastW = w; lastH = h;
  }

  const size = Math.min(w, h);
  const grid = BASE_GRID;
  const cell = size / grid;
  const cols = Math.ceil(w / cell);
  const rows = Math.ceil(h / cell);

  ctx.fillStyle = "#000000";
  ctx.fillRect(0, 0, w, h);

  for (let j = 0; j < rows; j++) {
    for (let i = 0; i < cols; i++) {
      const cx = (i + 0.5) * cell;
      const cy = (j + 0.5) * cell;
      const nx = cx / w;
      const ny = cy / h;

      // core drip intensity
      let dVal = dripField(nx, ny, time);

      if (dVal <= 0.01) continue; // keep pure black where nothing happens

      // add some wavy motion so it doesn't look static within the drip
      const wobble = driftNoise(nx, ny, time) * 0.25;
      let tVal = Math.max(0, Math.min(1, dVal + wobble * dVal));

      const col = sampleGradient(tVal);
      ctx.fillStyle = `rgb(${col.r},${col.g},${col.b})`;
      ctx.fillRect(
        i * cell,
        j * cell,
        Math.ceil(cell) + 1,
        Math.ceil(cell) + 1
      );
    }
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
